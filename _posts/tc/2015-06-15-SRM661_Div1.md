---
layout: post
title: TopCoder SRM661(Div.1)
tags: [TopCoder,数论]
category: TopCoder
---
#Div.1

##Level 1.MissingLCM

###Task

定义$$lcm(a_1,a_2,\ldots,a_n)$$为$$a_1,a_2,\ldots,a_n$$的最小公倍数,给定正整数$$N$$,求最小的$$M$$使得$$lcm(N+1,N+2,\ldots,M) = lcm(1,2,\ldots,M)$$

###Solution

![](/images/tc/srm661div1task1.jpg)

最大公倍数由质因数的最大倍数决定，枚举质数$$p$$，找到$$1.. N$$之间它的次数最大的项，便能算出下一次因数这么大或比它还大的时候($$p(\left[\frac{N}{kp}\right]+1)$$)

###Code

{% highlight cpp %}
class MissingLCM {
    public:
        const int maxn = 1000000+5;
		int getMin(int N)
        {
	        bool prime[maxn];
	        int ans=N+1;
	        memset(prime,-1,sizeof(prime));
	        for (int i=2;i<=N;i++)
	        {
		        if (prime[i])
		        {
			        long long p=i;
			        for (int j=i+i;j<=N;j+=i) prime[j]=0;
			        while (p*i <= N) p*=i;
			        ans=max((long long)ans,p*(N/p+1));
		        }
	        }
	        return ans;
        }
};
{% endhighlight %}

##Level2

##Level3
